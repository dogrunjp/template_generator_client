import {
  __commonJS
} from "./chunk-RSJERJUL.js";

// node_modules/@exodus/schemasafe/src/known-keywords.js
var require_known_keywords = __commonJS({
  "node_modules/@exodus/schemasafe/src/known-keywords.js"(exports, module) {
    "use strict";
    var knownKeywords = [
      ...["$schema", "$vocabulary"],
      // version
      ...["id", "$id", "$anchor", "$ref", "definitions", "$defs"],
      // pointers
      ...["$recursiveRef", "$recursiveAnchor", "$dynamicAnchor", "$dynamicRef"],
      ...["type", "required", "default"],
      // generic
      ...["enum", "const"],
      // constant values
      ...["not", "allOf", "anyOf", "oneOf", "if", "then", "else"],
      // logical checks
      ...["maximum", "minimum", "exclusiveMaximum", "exclusiveMinimum", "multipleOf", "divisibleBy"],
      // numbers
      ...["items", "maxItems", "minItems", "additionalItems", "prefixItems"],
      // arrays, basic
      ...["contains", "minContains", "maxContains", "uniqueItems"],
      // arrays, complex
      ...["maxLength", "minLength", "format", "pattern"],
      // strings
      ...["contentEncoding", "contentMediaType", "contentSchema"],
      // strings content
      ...["properties", "maxProperties", "minProperties", "additionalProperties", "patternProperties"],
      // objects
      ...["propertyNames"],
      // objects
      ...["dependencies", "dependentRequired", "dependentSchemas", "propertyDependencies"],
      // objects (dependencies)
      ...["unevaluatedProperties", "unevaluatedItems"],
      // see-through
      // Unused meta keywords not affecting validation (annotations and comments)
      // https://json-schema.org/understanding-json-schema/reference/generic.html
      // https://json-schema.org/draft/2019-09/json-schema-validation.html#rfc.section.9
      ...["title", "description", "deprecated", "readOnly", "writeOnly", "examples", "$comment"],
      // unused meta
      ...["example"],
      // unused meta, OpenAPI
      "discriminator",
      // optimization hint and error filtering only, does not affect validation result
      "removeAdditional"
      // optional keyword for { removeAdditional: 'keyword' } config, to target specific objects
    ];
    var schemaDrafts = [
      ...["draft/next"],
      // not recommended to use, might change / break in an unexpected way
      ...["draft/2020-12", "draft/2019-09"],
      // new
      ...["draft-07", "draft-06", "draft-04", "draft-03"]
      // historic
    ];
    var schemaVersions = schemaDrafts.map((draft) => `https://json-schema.org/${draft}/schema`);
    var vocab2019 = ["core", "applicator", "validation", "meta-data", "format", "content"];
    var vocab2020 = [
      ...["core", "applicator", "unevaluated", "validation"],
      ...["meta-data", "format-annotation", "format-assertion", "content"]
    ];
    var knownVocabularies = [
      ...vocab2019.map((v) => `https://json-schema.org/draft/2019-09/vocab/${v}`),
      ...vocab2020.map((v) => `https://json-schema.org/draft/2020-12/vocab/${v}`)
    ];
    module.exports = { knownKeywords, schemaVersions, knownVocabularies };
  }
});

// node_modules/@exodus/schemasafe/src/pointer.js
var require_pointer = __commonJS({
  "node_modules/@exodus/schemasafe/src/pointer.js"(exports, module) {
    var { knownKeywords } = require_known_keywords();
    function safeSet(map, key, value, comment = "keys") {
      if (!map.has(key))
        return map.set(key, value);
      if (map.get(key) !== value)
        throw new Error(`Conflicting duplicate ${comment}: ${key}`);
    }
    function untilde(string) {
      if (!string.includes("~"))
        return string;
      return string.replace(/~[01]/g, (match) => {
        switch (match) {
          case "~1":
            return "/";
          case "~0":
            return "~";
        }
        throw new Error("Unreachable");
      });
    }
    function get(obj, pointer, objpath) {
      if (typeof obj !== "object")
        throw new Error("Invalid input object");
      if (typeof pointer !== "string")
        throw new Error("Invalid JSON pointer");
      const parts = pointer.split("/");
      if (!["", "#"].includes(parts.shift()))
        throw new Error("Invalid JSON pointer");
      if (parts.length === 0)
        return obj;
      let curr = obj;
      for (const part of parts) {
        if (typeof part !== "string")
          throw new Error("Invalid JSON pointer");
        if (objpath)
          objpath.push(curr);
        const prop = untilde(part);
        if (typeof curr !== "object")
          return void 0;
        if (!Object.prototype.hasOwnProperty.call(curr, prop))
          return void 0;
        curr = curr[prop];
      }
      return curr;
    }
    var protocolRegex = /^https?:\/\//;
    function joinPath(baseFull, sub) {
      if (typeof baseFull !== "string" || typeof sub !== "string")
        throw new Error("Unexpected path!");
      if (sub.length === 0)
        return baseFull;
      const base = baseFull.replace(/#.*/, "");
      if (sub.startsWith("#"))
        return `${base}${sub}`;
      if (!base.includes("/") || protocolRegex.test(sub))
        return sub;
      if (protocolRegex.test(base))
        return `${new URL(sub, base)}`;
      if (sub.startsWith("/"))
        return sub;
      return [...base.split("/").slice(0, -1), sub].join("/");
    }
    function objpath2path(objpath) {
      const ids = objpath.map((obj) => obj && (obj.$id || obj.id) || "");
      return ids.filter((id) => id && typeof id === "string").reduce(joinPath, "");
    }
    var withSpecialChilds = ["properties", "patternProperties", "$defs", "definitions"];
    var skipChilds = ["const", "enum", "examples", "example", "comment"];
    var sSkip = Symbol("skip");
    function traverse(schema, work) {
      const visit = (sub, specialChilds = false) => {
        if (!sub || typeof sub !== "object")
          return;
        const res = work(sub);
        if (res !== void 0)
          return res === sSkip ? void 0 : res;
        for (const k of Object.keys(sub)) {
          if (!specialChilds && !Array.isArray(sub) && !knownKeywords.includes(k))
            continue;
          if (!specialChilds && skipChilds.includes(k))
            continue;
          const kres = visit(sub[k], !specialChilds && withSpecialChilds.includes(k));
          if (kres !== void 0)
            return kres;
        }
      };
      return visit(schema);
    }
    function resolveReference(root, schemas, ref, base = "") {
      const ptr = joinPath(base, ref);
      const results = [];
      const [main, hash = ""] = ptr.split("#");
      const local = decodeURI(hash);
      const visit = (sub, oldPath, specialChilds = false, dynamic = false) => {
        if (!sub || typeof sub !== "object")
          return;
        const id = sub.$id || sub.id;
        let path = oldPath;
        if (id && typeof id === "string") {
          path = joinPath(path, id);
          if (path === ptr || path === main && local === "") {
            results.push([sub, root, oldPath]);
          } else if (path === main && local[0] === "/") {
            const objpath = [];
            const res = get(sub, local, objpath);
            if (res !== void 0)
              results.push([res, root, joinPath(oldPath, objpath2path(objpath))]);
          }
        }
        const anchor = dynamic ? sub.$dynamicAnchor : sub.$anchor;
        if (anchor && typeof anchor === "string") {
          if (anchor.includes("#"))
            throw new Error("$anchor can't include '#'");
          if (anchor.startsWith("/"))
            throw new Error("$anchor can't start with '/'");
          path = joinPath(path, `#${anchor}`);
          if (path === ptr)
            results.push([sub, root, oldPath]);
        }
        for (const k of Object.keys(sub)) {
          if (!specialChilds && !Array.isArray(sub) && !knownKeywords.includes(k))
            continue;
          if (!specialChilds && skipChilds.includes(k))
            continue;
          visit(sub[k], path, !specialChilds && withSpecialChilds.includes(k));
        }
        if (!dynamic && sub.$dynamicAnchor)
          visit(sub, oldPath, specialChilds, true);
      };
      visit(root, main);
      if (main === base.replace(/#$/, "") && (local[0] === "/" || local === "")) {
        const objpath = [];
        const res = get(root, local, objpath);
        if (res !== void 0)
          results.push([res, root, objpath2path(objpath)]);
      }
      if (schemas.has(main) && schemas.get(main) !== root) {
        const additional = resolveReference(schemas.get(main), schemas, `#${hash}`, main);
        results.push(...additional.map(([res, rRoot, rPath]) => [res, rRoot, joinPath(main, rPath)]));
      }
      if (schemas.has(ptr))
        results.push([schemas.get(ptr), schemas.get(ptr), ptr]);
      return results;
    }
    function getDynamicAnchors(schema) {
      const results = /* @__PURE__ */ new Map();
      traverse(schema, (sub) => {
        if (sub !== schema && (sub.$id || sub.id))
          return sSkip;
        const anchor = sub.$dynamicAnchor;
        if (anchor && typeof anchor === "string") {
          if (anchor.includes("#"))
            throw new Error("$dynamicAnchor can't include '#'");
          if (!/^[a-zA-Z0-9_-]+$/.test(anchor))
            throw new Error(`Unsupported $dynamicAnchor: ${anchor}`);
          safeSet(results, anchor, sub, "$dynamicAnchor");
        }
      });
      return results;
    }
    var hasKeywords = (schema, keywords) => traverse(schema, (s) => Object.keys(s).some((k) => keywords.includes(k)) || void 0) || false;
    var addSchemasArrayToMap = (schemas, input, optional = false) => {
      if (!Array.isArray(input))
        throw new Error("Expected an array of schemas");
      for (const schema of input) {
        traverse(schema, (sub) => {
          const idRaw = sub.$id || sub.id;
          const id = idRaw && typeof idRaw === "string" ? idRaw.replace(/#$/, "") : null;
          if (id && id.includes("://") && !id.includes("#")) {
            safeSet(schemas, id, sub, "schema $id in 'schemas'");
          } else if (sub === schema && !optional) {
            throw new Error("Schema with missing or invalid $id in 'schemas'");
          }
        });
      }
      return schemas;
    };
    var buildSchemas = (input, extra) => {
      if (extra)
        return addSchemasArrayToMap(buildSchemas(input), extra, true);
      if (input) {
        switch (Object.getPrototypeOf(input)) {
          case Object.prototype:
            return new Map(Object.entries(input));
          case Map.prototype:
            return new Map(input);
          case Array.prototype:
            return addSchemasArrayToMap(/* @__PURE__ */ new Map(), input);
        }
      }
      throw new Error("Unexpected value for 'schemas' option");
    };
    module.exports = { get, joinPath, resolveReference, getDynamicAnchors, hasKeywords, buildSchemas };
  }
});

export {
  require_known_keywords,
  require_pointer
};
//# sourceMappingURL=chunk-ABMPPEUX.js.map
